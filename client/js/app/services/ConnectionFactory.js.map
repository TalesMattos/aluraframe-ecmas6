{"version":3,"sources":["../../app-es6/services/ConnectionFactory.js"],"names":["stores","idbName","idbVersion","connection","closeConn","ConnectionFactory","Error","Promise","resolve","reject","openRequest","window","indexedDB","open","onupgradeneeded","_createStores","e","target","result","onsuccess","console","log","close","bind","onerror","error","name","forEach","objectStoreNames","contains","store","deleteObjectStore","createObjectStore","autoIncrement"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaMA,kB,GAAS,CAAC,aAAD,C;AACTC,mB,GAAU,Y;AACVC,sB,GAAa,G;AACfC,sB,GAAa,I;AACbC,qB,GAAY,I;;yCAIHC,iB;AAET,6CAAc;AAAA;;AACV,0BAAM,IAAIC,KAAJ,CAAU,6CAAV,CAAN;AACH;;;;oDAEsB;;AAEnB,+BAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;;AAEpC,gCAAIC,cAAcC,OAAOC,SAAP,CAAiBC,IAAjB,CAAsBZ,OAAtB,EAA+BC,UAA/B,CAAlB;;AAEAQ,wCAAYI,eAAZ,GAA8B,aAAK;AAC/BT,kDAAkBU,aAAlB,CAAgCC,EAAEC,MAAF,CAASC,MAAzC;AACH,6BAFD;;AAIAR,wCAAYS,SAAZ,GAAwB,aAAK;AACzB,oCAAI,CAAChB,UAAL,EAAiB;AACbiB,4CAAQC,GAAR,CAAY,yCAAZ;AACAlB,iDAAaa,EAAEC,MAAF,CAASC,MAAtB;AACA;AACAd,gDAAYD,WAAWmB,KAAX,CAAiBC,IAAjB,CAAsBpB,UAAtB,CAAZ;AACA;AACAA,+CAAWmB,KAAX,GAAmB,YAAW;AAC1B,8CAAM,IAAIhB,KAAJ,CAAU,iDAAV,CAAN;AACH,qCAFD;AAGH;AACDE,wCAAQL,UAAR;AACH,6BAZD;;AAcAO,wCAAYc,OAAZ,GAAsB,aAAK;AACvBJ,wCAAQC,GAAR,CAAYL,EAAEC,MAAF,CAASQ,KAArB;AACAhB,uCAAOO,EAAEC,MAAF,CAASQ,KAAT,CAAeC,IAAtB;AACH,6BAHD;AAIH,yBA1BM,CAAP;AA2BH;;;kDAEoBvB,U,EAAY;AAC7BiB,gCAAQC,GAAR,uBAA+BrB,MAA/B,2BAAyDC,OAAzD,SAAoEC,UAApE;AACAF,+BAAO2B,OAAP,CAAe,iBAAS;AACpB,gCAAIxB,WAAWyB,gBAAX,CAA4BC,QAA5B,CAAqCC,KAArC,CAAJ,EAAiD;AAC7C3B,2CAAW4B,iBAAX,CAA6BD,KAA7B;AACH;AACD3B,uCAAW6B,iBAAX,CAA6BF,KAA7B,EAAoC,EAACG,eAAe,IAAhB,EAApC;AACH,yBALD;AAMH;;;sDAEwB;AACrB,4BAAI9B,UAAJ,EAAgB;AACZ;;;AAGAC;AACAD,yCAAa,IAAb;AACH;AACJ","file":"ConnectionFactory.js","sourcesContent":["\n/* Module Pattern: Unidade de código confinada em que ninguém tem acesso ao conteúdo dele.\n                    A partir daí, decidimos o que deve ser exportado para o mundo exterior com o 'return',\n                        no caso uma classe.\n    Uma maneira de criarmos um escopo privado no JavaScript é colocando o código em uma função. \n    'var ConnectionFactory' recebe uma função anônima auto-invocada e está com escopo global\n    Tudo isso para que as variáveis sejam privadas\n*/\n// Não é mais necessário esse padrão pois o código foi refatorado para usar o sistema de módulo do ES6\n// var ConnectionFactory = (function() {\n\n\n// no ES6 não é possível criar variável estáticas, portanto esse 'workaround'\nconst stores = ['negociacoes'];\nconst idbName = 'aluraframe';\nconst idbVersion = '3';\nlet connection = null; // só deve haver 1 conexão para a app (comum no JS, diferente do Java onde há pool de conexões)\nlet closeConn = null;\n\n// no ES6 não é possível criar variável estáticas, portanto esse 'workaround'\n// return class ConnectionFactory {\nexport class ConnectionFactory {\n\n    constructor() {\n        throw new Error('ConnectionFactory não pode ser instanciada.');\n    }\n\n    static getConnection() {\n        \n        return new Promise((resolve, reject) => {\n            \n            let openRequest = window.indexedDB.open(idbName, idbVersion);\n            \n            openRequest.onupgradeneeded = e => {\n                ConnectionFactory._createStores(e.target.result);\n            };\n        \n            openRequest.onsuccess = e => {\n                if (!connection) {\n                    console.log('inicializando conexão com Indexed-DB...');\n                    connection = e.target.result;\n                    //Guardando a função close original que está associada à nossa connection\n                    closeConn = connection.close.bind(connection);\n                    //Monkey Patch: sobrescreve um método\n                    connection.close = function() {\n                        throw new Error('Não é permitido fechar a conexão com Indexed-DB');\n                    };\n                }\n                resolve(connection);\n            };\n        \n            openRequest.onerror = e => {\n                console.log(e.target.error);\n                reject(e.target.error.name);\n            };\n        });\n    }\n\n    static _createStores(connection) {\n        console.log(`criando stores '${stores}' no Indexed-DB '${idbName}:${idbVersion}' ...`);\n        stores.forEach(store => {\n            if (connection.objectStoreNames.contains(store)) {\n                connection.deleteObjectStore(store);\n            } \n            connection.createObjectStore(store, {autoIncrement: true});\n        });\n    }\n\n    static closeConnection() {\n        if (connection) {\n            /*Sem usar o bind no contexto de connection, a chamada a close deveria ser assim: \n                Reflect.apply(closeConn, connection, []);\n            */\n            closeConn();\n            connection = null;\n        }\n    }\n}\n\n// })();"]}
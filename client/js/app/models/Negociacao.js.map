{"version":3,"sources":["../../app-es6/models/Negociacao.js"],"names":["DateHelper","Negociacao","data","quantidade","valor","pk","_pk","parseInt","_data","Date","getTime","_quantidade","_valor","parseFloat","outraNegociacao","dataParaTexto"],"mappings":";;;;;;;;;;;;;;;AAAQA,sB,sBAAAA,U;;;;;;;;;;;;;;;;;;;;;kCAGKC,U;AAAa;;AAEtB;;;;;;AAMA,oCAAYC,IAAZ,EAAkBC,UAAlB,EAA8BC,KAA9B,EAAqCC,EAArC,EAAyC;AAAA;;AACrC,wBAAIA,EAAJ,EACI,KAAKC,GAAL,GAAWC,SAASF,EAAT,CAAX;AACJ;AACA,yBAAKG,KAAL,GAAa,IAAIC,IAAJ,CAASP,KAAKQ,OAAL,EAAT,CAAb,CAJqC,CAIE;AACvC;AACA,yBAAKC,WAAL,GAAmBJ,SAASJ,UAAT,CAAnB,CANqC,CAMI;AACzC,yBAAKS,MAAL,GAAcC,WAAWT,KAAX,CAAd,CAPqC,CAOJ;AACjC;AACA;AACA;AACH;;AAED;;;;;;;;;;;;6CAkCSU,e,EAAiB;;AAEtB;;AAEA,4BAAI,KAAKT,EAAL,IAAWS,gBAAgBT,EAA/B,EACI,OAAO,KAAKA,EAAL,IAAWS,gBAAgBT,EAAlC;;AAEJ,+BAAOL,WAAWe,aAAX,CAAyB,KAAKb,IAA9B,KAAuCF,WAAWe,aAAX,CAAyBD,gBAAgBZ,IAAzC,CAAvC,IACI,KAAKC,UAAL,IAAmBW,gBAAgBX,UADvC,IAEI,KAAKC,KAAL,IAAcU,gBAAgBV,KAFzC;;AAIA;AACA;AACA;AACH;;;wCAtCQ;AACL,+BAAO,KAAKE,GAAZ;AACH,qB;sCAEMD,E,EAAI;AACP,6BAAKC,GAAL,GAAWC,SAASF,EAAT,CAAX;AACH;;;wCAEY;AACT,+BAAO,KAAKM,WAAL,GAAmB,KAAKC,MAA/B;AACH;;;wCAEU;AACP,+BAAO,IAAIH,IAAJ,CAAS,KAAKD,KAAL,CAAWE,OAAX,EAAT,CAAP,CADO,CACgC;AAC1C;;;wCAEgB;AACb,+BAAO,KAAKC,WAAZ;AACH;;;wCAEW;AACR,+BAAO,KAAKC,MAAZ;AACH","file":"Negociacao.js","sourcesContent":["import {DateHelper} from '../helpers/DateHelper'\r\n\r\n//sintaxe de criação de classe em ECMA-Script-6 somente\r\nexport class Negociacao { // Mesmo nome do arquivo para ficar claro, mas não é obrigatório\r\n\r\n    /* uso de '_' como prefixo é uma convenção para dizer que determinado atributo só deve ser alterado dentro da class.\r\n        (Ou seja, é um atributo somente de leitura, uma vez que javascript não possui modificadores de acesso, como o 'private')\r\n        (É apenas um aviso ao programador: 'Ei, não acesse essa variavel com prefixo '_')\r\n        Para acessar variáveis com prefixo '_' usar métodos acessadores. São métodos que tem oi prefixo 'get' \r\n       */\r\n\r\n    constructor(data, quantidade, valor, pk) {\r\n        if (pk)\r\n            this._pk = parseInt(pk);\r\n        /* Aqui declaramos as propriedades/atributos da classe. Aqui elas serão construídas. Não usar a palavra reservada 'var' como precedente dos atributos */\r\n        this._data = new Date(data.getTime()); // Programação defensiva (Assim como no Java, OO em JavaScript recebe parâmetros por referência \r\n        //   e se a referencia for alterada, também irá alterar o atributo que recebeu a referência)\r\n        this._quantidade = parseInt(quantidade); // quantidade já é imutavel (não tem método para alterar seu valor, a não ser pela atribuição direta com '=')\r\n        this._valor = parseFloat(valor); // valor já é imutavel (não tem método para alterar seu valor, a não ser pela atribuição direta com '=')\r\n        // Object.freeze(this); // torna o objeto imutavel (nem mesmo as variaveis privadas por convenção agora podem ser modificadas)\r\n        // No entanto, Object.freeze(this) é Shallow, superficial e não consegue imutar o atributa data por exemplo, pois ele também é um objeto\r\n        //n.data.setDate(1) irá altarar o valor da data (não a data propriamente dita) se não houver uma programação defensiva\r\n    }\r\n\r\n    /* esses são métodos (não funções) - chama-se método por conveção,\r\n        pois está em uma classee também porque não possui a palavra reservada function\r\n        Exemplo:\r\n                    getData() {\r\n                        return this._data;\r\n                    }\r\n        Mas também é possível: usar a palavra reservada 'get' para acessar a propriedade, somente, como leitura.\r\n        E a sintaxe de chamada não exigirá os '()' e nem o prefixo 'get', será acessada como se fosse uma propriedade da classe\r\n        */\r\n    \r\n    get pk() {\r\n        return this._pk;\r\n    }\r\n\r\n    set pk(pk) {\r\n        this._pk = parseInt(pk);\r\n    }\r\n\r\n    get volume() {\r\n        return this._quantidade * this._valor;\r\n    }\r\n\r\n    get data() {\r\n        return new Date(this._data.getTime()); // Programação defensiva para evitar alteração do valor da data\r\n    }\r\n\r\n    get quantidade() {\r\n        return this._quantidade;\r\n    }\r\n\r\n    get valor() {\r\n        return this._valor;\r\n    }\r\n\r\n    isEquals(outraNegociacao) {        \r\n        \r\n        // return JSON.stringify(this) == JSON.stringify(outraNegociacao)\r\n        \r\n        if (this.pk && outraNegociacao.pk)\r\n            return this.pk == outraNegociacao.pk;\r\n        \r\n        return DateHelper.dataParaTexto(this.data) == DateHelper.dataParaTexto(outraNegociacao.data)\r\n                && this.quantidade == outraNegociacao.quantidade\r\n                && this.valor == outraNegociacao.valor;\r\n\r\n        // se só a data e o valor fosse critérios de comparação\r\n        // return this._data.getTime() == outraNegociacao.data.getTime()\r\n        //     && this._valor == outraNegociacao.valor;\r\n    }\r\n\r\n}"]}
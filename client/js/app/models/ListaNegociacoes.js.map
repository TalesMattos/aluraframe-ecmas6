{"version":3,"sources":["../../app-es6/models/ListaNegociacoes.js"],"names":["ListaNegociacoes","_negociacoes","e","push","index","splice","console","log","comparator","sort","reverse","concat","reduce","total","n","volume","listaNegociacoes","negociacao","some","isEquals","negociacaoExistente","i","length","negItem"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wCACaA,gB;AAET,4CAAY,uBAAyB;AAAA;;AACjC;AACA;AACA,yBAAKC,YAAL,GAAoB,EAApB;AACA;AACH;;;;wCAEGC,C,EAAG;AACH;;AAEA,6BAAKD,YAAL,CAAkBE,IAAlB,CAAuBD,CAAvB,EAHG,CAGwB;AAC3B;;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;;AAEA;AACH;;;4CAEOE,K,EAAO;AACX,4BAAIA,SAAS,CAAb,EACI,KAAKH,YAAL,CAAkBI,MAAlB,CAAyBD,KAAzB,EAAgC,CAAhC;AACP;;;8CAOS;AACNE,gCAAQC,GAAR,CAAY,eAAZ;;AAEA,6BAAKN,YAAL,GAAoB,EAApB;AACA;AACH;;;2CAQMO,U,EAAY;AACf,6BAAKP,YAAL,CAAkBQ,IAAlB,CAAuBD,UAAvB;AACH;;;oDAEe;AACZ,6BAAKP,YAAL,CAAkBS,OAAlB;AACH;;;wCAxBU;AACP;AACA,+BAAO,GAAGC,MAAH,CAAU,KAAKV,YAAf,CAAP;AACH;;;wCASiB;AACf;AACA;AACA,+BAAO,KAAKA,YAAL,CAAkBW,MAAlB,CAAyB,UAACC,KAAD,EAAQC,CAAR;AAAA,mCAAcD,QAAQC,EAAEC,MAAxB;AAAA,yBAAzB,EAAyD,GAAzD,CAAP,CAHe,CAGuD;AACxE;;;gEAUkCC,gB,EAAkBC,U,EAAY;AAC7D,+BAAOD,iBAAiBE,IAAjB,CAAsB;AAAA,mCAAuB;AAC5CD,2CAAWE,QAAX,CAAoBC,mBAApB;AADqB;AAAA,yBAAtB,CAC0C;AACzC;AAFD,yBAAP;AAIH;;;iEAEmCJ,gB,EAAkBC,U,EAAY;AAC9D,4BAAI,CAACD,gBAAD,IAAqB,CAACC,UAA1B,EACI;AACJ,6BAAK,IAAII,IAAI,CAAb,EAAgBA,IAAIL,iBAAiBM,MAArC,EAA6CD,GAA7C,EAAkD;AAC9C,gCAAIE,UAAUP,iBAAiBK,CAAjB,CAAd;AACA,gCAAIJ,WAAWE,QAAX,CAAoBI,OAApB,CAAJ,EAAkC;AAC9B,uCAAOF,CAAP;AACH;AACJ;AACJ","file":"ListaNegociacoes.js","sourcesContent":["\r\nexport class ListaNegociacoes {\r\n\r\n    constructor(/*contexto, armadilha*/) {\r\n        //this._contexto = contexto; // somente é usado quando passamos o contexto por function tradicional e não arrow function\r\n        //this._armadilha = armadilha; // Não vamos mais usar armadilha (Observer Pattern) para não poluir o modelo, vamos usar proxy\r\n        this._negociacoes = [];\r\n        // Object.freeze(this); // se não comentar não será possível esvaziar a lista\r\n    }\r\n\r\n    add(e) {\r\n        // console.log('adicionando...');\r\n\r\n        this._negociacoes.push(e); // trap do proxy não consegue interceptar pois não há atribuição na propriedade _negociacoes \r\n        //this._negociacoes = [].concat(this._negociacoes, e); //gambiarra para a trap/armadilha do proxy poder interceptar a adição (não deve ser usado, não é performático)\r\n\r\n        /*Como a _armadilha foi passada por meio de arrow function, onde o 'this' é estático/léxico \r\n                ('this' é fixo, ou seja, é o mesmo contexto do objeto ao qual a arrow function está inserida, declarada) \r\n            e não por meio de uma function normal, onde o 'this' é dinâmico\r\n                ('this' varia de acordo com o contexto ao qual a função é chamada e não declarada)\r\n            então, vamos deixar comentada essa possibilidade\r\n        */\r\n        // API de reflexão do javascript. Recebe: \r\n        //    a função a ser executada\r\n        //    o contexto em que vai ser executada\r\n        //    array de parametros que será passado junto com a função, no caso o modele (esse objeto atual)\r\n        // Reflect.apply(this._armadilha, this._contexto, [this]);\r\n\r\n        //this._armadilha(this); // chama a função armadilha passando o modelo, que é ele mesmo\r\n    }\r\n\r\n    remover(index) { \r\n        if (index >= 0)\r\n            this._negociacoes.splice(index, 1);\r\n    }\r\n\r\n    get list() {\r\n        //Programação defensiva: cria um novo array com uma cópia do que foi passado\r\n        return [].concat(this._negociacoes);\r\n    }\r\n\r\n    esvazia() {\r\n        console.log('esvaziando...');\r\n\r\n        this._negociacoes = [];\r\n        //this._armadilha(this);\r\n    }\r\n\r\n    get volumeTotal() {\r\n       // de maneira funcional. reduce() processa o array e retorna um valor\r\n       // o retorno de cada iteração é atribuido a variavel do primeiro parametro da function\r\n       return this._negociacoes.reduce((total, n) => total + n.volume, 0.0); // '0.0' é um parametro que inicializa o total \r\n    }\r\n\r\n    ordena(comparator) {\r\n        this._negociacoes.sort(comparator);\r\n    }\r\n\r\n    ordenaReverso() {\r\n        this._negociacoes.reverse();\r\n    }\r\n\r\n    static isNegociacaoJaExisteNaLista(listaNegociacoes, negociacao) {\r\n        return listaNegociacoes.some(negociacaoExistente => // varre o array e retorna true se encontrar uma correspondência. quanto encontra já para de percorrer\r\n                negociacao.isEquals(negociacaoExistente) // comparando strings, pq objetos estão apontando para regiões de memória diferentes\r\n                // listaNegociacoes.indexOf(negociacao) == -1)) // indexOf retorna a posição no array ou -1 se não achar (não funciona pq não consegue comparar objetos: estão a)\r\n            );\r\n    }\r\n\r\n    static obterPosicaoNegociacaoNLista(listaNegociacoes, negociacao) {\r\n        if (!listaNegociacoes || !negociacao)\r\n            return;\r\n        for (var i = 0; i < listaNegociacoes.length; i++) {\r\n            var negItem = listaNegociacoes[i];\r\n            if (negociacao.isEquals(negItem)) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n\r\n}"]}